<head><script type="text/javascript" src="html/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="html/font-awesome.min.css"></link><link rel="stylesheet" type="text/css" href="html/ui.fancytree.min.css"></link><script type="text/javascript" src="html/jquery.fancytree-all-deps.min.js"></script><script type="text/javascript" src="html/jquery.fancytree.glyph.js"></script><script type="text/javascript" src="html/jquery.fancytree.persist.js"></script><script type="text/javascript" src="html/report.js"></script><link rel="stylesheet" type="text/css" href="html/prism.css"></link><link rel="stylesheet" type="text/css" href="html/report.css"></link><link rel="stylesheet" type="text/css" href="html/fontawesome/fontawesome-all.min.css"></link><link media="screen,projection" rel="stylesheet" type="text/css" href="html/materialise/css/materialize.min.css"></link><meta name="viewport" content="width=device-width, initial-scale=1.0"></meta><meta charset="UTF-8"></meta></head>
        <ul id="slide-out" class="side-nav">
             <h5>Settings</h5>
             <div class="divider"></div>
             <div class="switch" id="matchless_files">
                Remove matchless files:
                <label>
                  Off
                  <input type="checkbox">
                  <span class="lever"></span>
                  On
                </label>
            </div>
            <script>
                $(function() {
                    if (localStorage.getItem('matchless_files') === "true"){
                    removeUnimportantFiles();
                    $('#matchless_files').find("input[type=checkbox]").prop('checked', true);
                    }
                });
                $("#matchless_files").find("input[type=checkbox]").on("change",function() {
                    var status = $(this).prop('checked');
                    if (status==true){
                        removeUnimportantFiles();
                        localStorage.setItem('matchless_files', true); 
                    }else{
                         Materialize.toast('Refresh page to take effect.', 4000);
                         localStorage.setItem('matchless_files', false); 
                    }
                     console.log(status);
                });
            </script>
            Expand tree: <a id="expand_tree" class="waves-effect waves-light btn" style="background-color: #30363A !important;height: 24px;line-height: 24px;padding: 0 0.5rem;">Expand</a>
            <script>
                $( "#expand_tree" ).click(function() {
                  $("#tree").fancytree("getTree").visit(function(node){
                    node.setExpanded();
                  });
                });
            </script>
        </ul>
        
            <nav>
                <div class="nav-wrapper" style="background-color: #30363A !important;">
                  <a href="start.html" class="brand-logo center" style="position:relative;"><img style="height:100%;" src="html/logo.png"></a>
                  <ul id="nav-mobile" class="right hide-on-med-and-down">

                            
                <li><a href="start.html">Treeview</a></li>
                <li><a href="lootbox.html">Lootbox</a></li>
                <li><a href="log.html">Logs</a></li>
                
                    <li><a href="#" data-activates="slide-out" id="button-collapse" class="button"><i class="material-icons">settings</i></a></li>
                        <script>
                        $(function() {
                            // Initialize collapse button
                            $("#button-collapse").sideNav();
                            // Initialize collapsible (uncomment the line below if you use the dropdown variation)
                            //$('.collapsible').collapsible();
                        });
                        </script>
                    </ul>
                </div>
            </nav>
        <div class="jadx_source_code_div"><h1 class="jadx_source_code_title center-align">Project: xumo_apk</h1><div class="row"><div id="tree" class="col s12 m12 l3"></div><div id="codeview" class="col s12 m12 l9">
                <script>
                $( document ).ready(function() {
                    Materialize.toast('No matches found in this file', 9000)
                });
                </script>
                <div class="chip col"><i class="material-icons">attach_file</i><a href="html/view_source.html?file=/Users/Max/Desktop/deploy/xumo_apk/jadx_source_code/androidx/lifecycle/ClassesInfoCache.java" target="_blank">/xumo_apk/jadx_source_code/androidx/lifecycle/ClassesInfoCache.java</a></div><div class="row"><div class="col s12"><div class="card"><div class="card-content"><h5>Source code</h5><pre data-src="ClassesInfoCache.java" data-line="" class="code line-numbers"><code>package androidx.lifecycle;

import androidx.annotation.Nullable;
import androidx.lifecycle.Lifecycle.Event;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

class ClassesInfoCache {
    private static final int CALL_TYPE_NO_ARG = 0;
    private static final int CALL_TYPE_PROVIDER = 1;
    private static final int CALL_TYPE_PROVIDER_WITH_EVENT = 2;
    static ClassesInfoCache sInstance = new ClassesInfoCache();
    private final Map&lt;Class, CallbackInfo&gt; mCallbackMap = new HashMap();
    private final Map&lt;Class, Boolean&gt; mHasLifecycleMethods = new HashMap();

    static class CallbackInfo {
        final Map&lt;Event, List&lt;MethodReference&gt;&gt; mEventToHandlers = new HashMap();
        final Map&lt;MethodReference, Event&gt; mHandlerToEvent;

        CallbackInfo(Map&lt;MethodReference, Event&gt; map) {
            this.mHandlerToEvent = map;
            map = map.entrySet().iterator();
            while (map.hasNext()) {
                Entry entry = (Entry) map.next();
                Event event = (Event) entry.getValue();
                List list = (List) this.mEventToHandlers.get(event);
                if (list == null) {
                    list = new ArrayList();
                    this.mEventToHandlers.put(event, list);
                }
                list.add(entry.getKey());
            }
        }

        void invokeCallbacks(LifecycleOwner lifecycleOwner, Event event, Object obj) {
            invokeMethodsForEvent((List) this.mEventToHandlers.get(event), lifecycleOwner, event, obj);
            invokeMethodsForEvent((List) this.mEventToHandlers.get(Event.ON_ANY), lifecycleOwner, event, obj);
        }

        private static void invokeMethodsForEvent(List&lt;MethodReference&gt; list, LifecycleOwner lifecycleOwner, Event event, Object obj) {
            if (list != null) {
                for (int size = list.size() - 1; size &gt;= 0; size--) {
                    ((MethodReference) list.get(size)).invokeCallback(lifecycleOwner, event, obj);
                }
            }
        }
    }

    static class MethodReference {
        final int mCallType;
        final Method mMethod;

        MethodReference(int i, Method method) {
            this.mCallType = i;
            this.mMethod = method;
            this.mMethod.setAccessible(true);
        }

        void invokeCallback(LifecycleOwner lifecycleOwner, Event event, Object obj) {
            try {
                switch (this.mCallType) {
                    case 0:
                        this.mMethod.invoke(obj, new Object[0]);
                        return;
                    case 1:
                        this.mMethod.invoke(obj, new Object[]{lifecycleOwner});
                        return;
                    case 2:
                        this.mMethod.invoke(obj, new Object[]{lifecycleOwner, event});
                        return;
                    default:
                        return;
                }
            } catch (LifecycleOwner lifecycleOwner2) {
                throw new RuntimeException("Failed to call observer method", lifecycleOwner2.getCause());
            } catch (LifecycleOwner lifecycleOwner22) {
                throw new RuntimeException(lifecycleOwner22);
            }
        }

        public boolean equals(Object obj) {
            boolean z = true;
            if (this == obj) {
                return true;
            }
            if (obj != null) {
                if (getClass() == obj.getClass()) {
                    MethodReference methodReference = (MethodReference) obj;
                    if (this.mCallType != methodReference.mCallType || this.mMethod.getName().equals(methodReference.mMethod.getName()) == null) {
                        z = false;
                    }
                    return z;
                }
            }
            return false;
        }

        public int hashCode() {
            return (this.mCallType * 31) + this.mMethod.getName().hashCode();
        }
    }

    ClassesInfoCache() {
    }

    boolean hasLifecycleMethods(Class cls) {
        if (this.mHasLifecycleMethods.containsKey(cls)) {
            return ((Boolean) this.mHasLifecycleMethods.get(cls)).booleanValue();
        }
        Method[] declaredMethods = getDeclaredMethods(cls);
        for (Method annotation : declaredMethods) {
            if (((OnLifecycleEvent) annotation.getAnnotation(OnLifecycleEvent.class)) != null) {
                createInfo(cls, declaredMethods);
                return true;
            }
        }
        this.mHasLifecycleMethods.put(cls, Boolean.valueOf(false));
        return false;
    }

    private Method[] getDeclaredMethods(Class cls) {
        try {
            return cls.getDeclaredMethods();
        } catch (Class cls2) {
            throw new IllegalArgumentException("The observer class has some methods that use newer APIs which are not available in the current OS version. Lifecycles cannot access even other methods so you should make sure that your observer classes only access framework classes that are available in your min API level OR use lifecycle:compiler annotation processor.", cls2);
        }
    }

    CallbackInfo getInfo(Class cls) {
        CallbackInfo callbackInfo = (CallbackInfo) this.mCallbackMap.get(cls);
        if (callbackInfo != null) {
            return callbackInfo;
        }
        return createInfo(cls, null);
    }

    private void verifyAndPutHandler(Map&lt;MethodReference, Event&gt; map, MethodReference methodReference, Event event, Class cls) {
        Event event2 = (Event) map.get(methodReference);
        if (event2 != null) {
            if (event != event2) {
                map = methodReference.mMethod;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Method ");
                stringBuilder.append(map.getName());
                stringBuilder.append(" in ");
                stringBuilder.append(cls.getName());
                stringBuilder.append(" already declared with different @OnLifecycleEvent value: previous");
                stringBuilder.append(" value ");
                stringBuilder.append(event2);
                stringBuilder.append(", new value ");
                stringBuilder.append(event);
                throw new IllegalArgumentException(stringBuilder.toString());
            }
        }
        if (event2 == null) {
            map.put(methodReference, event);
        }
    }

    private CallbackInfo createInfo(Class cls, @Nullable Method[] methodArr) {
        Class superclass = cls.getSuperclass();
        Map hashMap = new HashMap();
        if (superclass != null) {
            CallbackInfo info = getInfo(superclass);
            if (info != null) {
                hashMap.putAll(info.mHandlerToEvent);
            }
        }
        for (Class info2 : cls.getInterfaces()) {
            for (Entry entry : getInfo(info2).mHandlerToEvent.entrySet()) {
                verifyAndPutHandler(hashMap, (MethodReference) entry.getKey(), (Event) entry.getValue(), cls);
            }
        }
        if (methodArr == null) {
            methodArr = getDeclaredMethods(cls);
        }
        boolean z = false;
        for (Method method : r13) {
            OnLifecycleEvent onLifecycleEvent = (OnLifecycleEvent) method.getAnnotation(OnLifecycleEvent.class);
            if (onLifecycleEvent != null) {
                int i;
                Class[] parameterTypes = method.getParameterTypes();
                if (parameterTypes.length &lt;= 0) {
                    i = 0;
                } else if (parameterTypes[0].isAssignableFrom(LifecycleOwner.class)) {
                    i = 1;
                } else {
                    throw new IllegalArgumentException("invalid parameter type. Must be one and instanceof LifecycleOwner");
                }
                Event value = onLifecycleEvent.value();
                if (parameterTypes.length &gt; 1) {
                    if (!parameterTypes[1].isAssignableFrom(Event.class)) {
                        throw new IllegalArgumentException("invalid parameter type. second arg must be an event");
                    } else if (value == Event.ON_ANY) {
                        i = 2;
                    } else {
                        throw new IllegalArgumentException("Second arg is supported only for ON_ANY value");
                    }
                }
                if (parameterTypes.length &lt;= 2) {
                    verifyAndPutHandler(hashMap, new MethodReference(i, method), value, cls);
                    z = true;
                } else {
                    throw new IllegalArgumentException("cannot have more than 2 params");
                }
            }
        }
        methodArr = new CallbackInfo(hashMap);
        this.mCallbackMap.put(cls, methodArr);
        this.mHasLifecycleMethods.put(cls, Boolean.valueOf(z));
        return methodArr;
    }
}
</code></pre></div></div></div></div></div></div>
            <script src="tree_js_content.js"></script>
            </div><script data-manual type="text/javascript" src="html/prism.js"></script><script type="text/javascript" src="html/materialise/js/materialize.min.js"></script><footer style="background-color: #30363A !important;" class="page-footer"><div class="container"><div class="row"><div class="col l6 s12"><h5 class="white-text">StaCoAn</h5><p class="grey-text text-lighten-4">If you like this project, feel free to give this a star on Github.If you don't and would like to see other features, feel free to make a feature request.</p></div><div class="col l4 offset-l2 s12"><h5 class="white-text">links</h5><ul><li><a href="https://github.com/vincentcox/StaCoAn" class="grey-text text-lighten-3">StaCoAn Github page</a></li><li><a href="https://github.com/vincentcox/StaCoAn/blob/master/LICENSE" class="grey-text text-lighten-3">License</a></li></ul></div></div></div><div class="footer-copyright"><div class="container">Report generated at 21:0:3 5/11/2019</div></div></footer><script type="text/javascript" src="html/looty.js"></script>